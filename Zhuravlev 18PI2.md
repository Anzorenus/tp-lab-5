## 1 - Какие требования (функциональные/нефункциональные) предъявляются к классу Деканат?
#### Функциональные требования:
* Создание групп на основе данных из файла и создание и добавление студентов, на основе данных из другого файла
* Добавление случйаных оценок студентам
* Отчисление студентов за неуспеваемость
* Перевод студентов в другую группу
* Сохранение обновленных данных в файл
* Выборы старост
* Вывод данных на консоль
#### Нефункциональные требования:
* Студенты в текстовом файле должны быть описаны в формате
   ``<id> <last_name> <first_name> <second_name>;<group_name``
* Нужно указывать два имени файла конструктору деканата, иначе не будут созданны ни группы, ни студенты
* Группы хранятся в std::map, ключами в котором являются названия групп
* Отчисляются студенты, у которых средняя оценка ниже 3.51. Если студент был старостой, то выбирается новый
* Для перевода студента в другую группу, нужно указать название группы, откуда переводить, и название группы куад переводить, а также id студента
* Старосты выбираются случайно в каждой группе

## 2 - Как правильно протестировать работу Студента?
*Для примеров использую свои тесты из ПР*
1 - Для начала нужно протестировать, правильно ли создается экземпляр студента
```cpp
TEST(student_test, FIO_check) {
	Student* st = new Student("1 Иванов Иван Иванович", NULL);
	EXPECT_EQ("Иванов", st->get_last_name());
	EXPECT_EQ("Иван", st->get_first_name());
	EXPECT_EQ("Иванович", st->get_second_name());
	EXPECT_EQ(1, st->get_id());
}
```
Здесь идет проверка на то, что основные поля, ответственные за идентификацию студента (ФИО и id) заполняются правильно
2 - Затем тестирутеся правильность добавления оценок и подсчета средней оценки
```cpp
TEST(student_test, mean_check) {
	Student* st = new Student("1 Иванов Иван Иванович", NULL);
	srand(time(NULL));
	st->add_mark(4);
	st->add_mark(5);
	st->add_mark(6);
	EXPECT_EQ(5, st->mean_marks());
}
```
###### Здесь ``st->mean_marks()`` подсчитывает среднюю оценку и сразу же возвращает ее, при этом сохраняя как поле класса
3 - Затем идет проверка на то, что студента можно сделать старостой
```cpp
TEST(student_test, head_check) {
	Student* st = new Student("1 Иванов Иван Иванович", NULL);
	EXPECT_EQ(false, st->is_group_head());
	st->set_as_head();
	EXPECT_EQ(true, st->is_group_head());
}
```
Первым тестов проверяется, что сразу после создания студент не является старостой, и только после выполнения метода ``set_as_head()`` он становится им

## 3 - Можно ли вернуть вектор значений как копию из функции?
Да. Можно в выражении вызвать конструктор копирования ``std::vector``, потому что иначе из за механизма  ``RVO, Return value optimization ``  при возвращении самого ``arr``, он создается в контексте вызывающего кода. Фактически компилятор реализует передачу по ссылке
```cpp
std::vector<int> fun() {
	std::vector<int> arr = {1, 2, 3};
	return std::vector<int>(arr);
}
```

## 4 - Какие требования (функциональные/нефункциональные) предъявляются к классу Студент?
#### Функциональные требования:
* Создание студента с указание фио и id
* Зачисление в группу
* Добавление оценки
* Вычисление средней оценки
#### Нефункциональные требования:
* Имя, фамилия и отчество - отдельные приватные поля класса с геттерами
* Конструктору нужно передать строку в формате 
  ``<id> <last_name> <first_name> <second_name>`` и ссылку на группу
* Оценки и id должны быть целыми неотрицательными

## 5 - В чем разница между передачей в функцию параметра const string& и string& ?
В случае передачи ``const std::string&``, значение аргумента нельзя будет менять, тогда как без ``const`` - можно.
```cpp
void fun(const std::string& str) {
	str = "123";   //compile error
	std::cout << "Completed" << std::endl;
}

int main(int argc, const char * argv[]) {
	std::string s = "123456";
	fun(s);
	
	return 0;
}
```
